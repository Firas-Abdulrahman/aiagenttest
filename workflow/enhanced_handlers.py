# workflow/enhanced_handlers.py
"""
Enhanced Message Handlers with Deep AI Integration
Provides natural language understanding while maintaining structured workflow
"""

import logging
import time
from typing import Dict, Any, Optional
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


class EnhancedMessageHandler:
    """Enhanced message handler with deep AI integration for natural language understanding"""

    def __init__(self, database_manager, enhanced_ai_processor, action_executor):
        self.db = database_manager
        self.ai = enhanced_ai_processor  # Enhanced AI processor
        self.executor = action_executor

    def handle_message(self, message_data: Dict[str, Any]) -> Dict[str, Any]:
        """Enhanced message handling with AI-first approach"""
        try:
            text = message_data.get('text', {}).get('body', '').strip()
            phone_number = message_data.get('from')
            customer_name = self._extract_customer_name(message_data)

            # Get current session
            session = self.db.get_user_session(phone_number)
            current_step = session.get('current_step') if session else 'waiting_for_language'

            # Build comprehensive user context
            user_context = self._build_user_context(phone_number, session, current_step)

            # AI-First Processing: Try AI understanding first
            if self.ai and self.ai.is_available():
                logger.info(f"ğŸ§  Using enhanced AI for message: '{text}' at step '{current_step}'")
                ai_result = self.ai.understand_natural_language(
                    user_message=text,
                    current_step=current_step,
                    user_context=user_context,
                    language=session.get('language_preference', 'arabic') if session else 'arabic'
                )
                
                # Handle AI result
                if ai_result and ai_result.get('confidence') != 'low':
                    return self._handle_ai_result(phone_number, ai_result, session, user_context)
                else:
                    logger.info("ğŸ”„ AI confidence low, falling back to structured processing")

            # Fallback to structured processing
            return self._handle_structured_message(phone_number, text, current_step, session, user_context)

        except Exception as e:
            logger.error(f"âŒ Error in enhanced message handling: {str(e)}")
            return self._create_response("Ø­Ø¯Ø« Ø®Ø·Ø£. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©\nAn error occurred. Please try again")

    def _build_user_context(self, phone_number: str, session: Dict, current_step: str) -> Dict:
        """Build comprehensive user context for AI understanding"""
        context = {
            'phone_number': phone_number,
            'current_step': current_step,
            'language': session.get('language_preference', 'arabic') if session else 'arabic',
            'customer_name': session.get('customer_name', 'Customer') if session else 'Customer',
            'selected_main_category': session.get('selected_main_category'),
            'selected_sub_category': session.get('selected_sub_category'),
            'last_selected_item': session.get('last_selected_item'),
            'order_history': [],
            'current_order_items': [],
            'available_categories': [],
            'current_category_items': [],
            'conversation_history': []
        }

        # Get current order items
        if session:
            current_order = self.db.get_current_order(phone_number)
            if current_order:
                context['current_order_items'] = current_order.get('items', [])
                context['order_history'] = self.db.get_order_history(phone_number)

        # Get available categories based on current step
        if current_step == 'waiting_for_category':
            context['available_categories'] = self.db.get_main_categories()
        elif current_step == 'waiting_for_sub_category' and session.get('selected_main_category'):
            context['available_categories'] = self.db.get_sub_categories(session['selected_main_category'])
        elif current_step == 'waiting_for_item' and session.get('selected_sub_category'):
            context['current_category_items'] = self.db.get_sub_category_items(session['selected_sub_category'])

        return context

    def _handle_ai_result(self, phone_number: str, ai_result: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI understanding result with appropriate actions"""
        action = ai_result.get('action')
        extracted_data = ai_result.get('extracted_data', {})
        response_message = ai_result.get('response_message', '')
        language = user_context.get('language', 'arabic')

        logger.info(f"ğŸ¤– AI Action: {action} with data: {extracted_data}")

        try:
            if action == 'intelligent_suggestion':
                return self._handle_intelligent_suggestion(phone_number, ai_result, session, user_context)

            elif action == 'language_selection':
                return self._handle_ai_language_selection(phone_number, extracted_data, session)

            elif action == 'category_selection':
                return self._handle_ai_category_selection(phone_number, extracted_data, session, user_context)

            elif action == 'item_selection':
                return self._handle_ai_item_selection(phone_number, extracted_data, session, user_context)

            elif action == 'quantity_selection':
                return self._handle_ai_quantity_selection(phone_number, extracted_data, session, user_context)

            elif action == 'yes_no':
                return self._handle_ai_yes_no(phone_number, extracted_data, session, user_context)

            elif action == 'service_selection':
                return self._handle_ai_service_selection(phone_number, extracted_data, session, user_context)

            elif action == 'location_input':
                return self._handle_ai_location_input(phone_number, extracted_data, session, user_context)

            elif action == 'confirmation':
                return self._handle_ai_confirmation(phone_number, extracted_data, session, user_context)

            elif action == 'show_menu':
                return self._handle_ai_show_menu(phone_number, session, user_context)

            elif action == 'help_request':
                return self._handle_ai_help_request(phone_number, session, user_context)

            else:
                logger.warning(f"âš ï¸ Unknown AI action: {action}")
                return self._create_response(response_message or self._get_fallback_message(user_context['current_step'], language))

        except Exception as e:
            logger.error(f"âŒ Error handling AI result: {e}")
            return self._create_response(self._get_fallback_message(user_context['current_step'], language))

    def _handle_intelligent_suggestion(self, phone_number: str, ai_result: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle intelligent suggestions from AI"""
        extracted_data = ai_result.get('extracted_data', {})
        response_message = ai_result.get('response_message', '')
        language = user_context.get('language', 'arabic')
        current_step = user_context.get('current_step')

        # Handle main category suggestions
        suggested_main_category = extracted_data.get('suggested_main_category')
        if suggested_main_category and current_step == 'waiting_for_category':
            # Get the suggested main category
            main_categories = self.db.get_main_categories()
            if 1 <= suggested_main_category <= len(main_categories):
                selected_category = main_categories[suggested_main_category - 1]
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_sub_category', language,
                    session.get('customer_name'),
                    selected_main_category=selected_category['id']
                )
                
                # Show sub-categories
                return self._show_sub_categories(phone_number, selected_category, language)

        # Handle sub-category suggestions
        suggested_sub_category = extracted_data.get('suggested_sub_category')
        if suggested_sub_category and current_step == 'waiting_for_sub_category':
            # Get the suggested sub-category
            sub_categories = self.db.get_sub_categories(session.get('selected_main_category'))
            if 1 <= suggested_sub_category <= len(sub_categories):
                selected_sub_category = sub_categories[suggested_sub_category - 1]
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_item', language,
                    session.get('customer_name'),
                    selected_main_category=session.get('selected_main_category'),
                    selected_sub_category=selected_sub_category['id']
                )
                
                # Show items
                return self._show_sub_category_items(phone_number, selected_sub_category, language)

        # If no specific suggestions, use the AI's response message
        if response_message:
            return self._create_response(response_message)
        else:
            return self._create_response(self._get_fallback_message(current_step, language))

    def _handle_ai_language_selection(self, phone_number: str, extracted_data: Dict, session: Dict) -> Dict:
        """Handle AI language selection"""
        language = extracted_data.get('language')
        
        if language not in ['arabic', 'english']:
            return self._create_response("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù„ØºØ© ØµØ­ÙŠØ­Ø©\nPlease select a valid language")

        # Create session with language preference
        self.db.create_or_update_session(
            phone_number, 'waiting_for_category', language,
            session.get('customer_name') if session else 'Customer'
        )

        # Show main categories
        return self._show_main_categories(phone_number, language)

    def _handle_ai_category_selection(self, phone_number: str, extracted_data: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI category selection"""
        category_id = extracted_data.get('category_id')
        category_name = extracted_data.get('category_name')
        language = user_context.get('language')

        if category_id:
            # Direct category ID selection
            main_categories = self.db.get_main_categories()
            if 1 <= category_id <= len(main_categories):
                selected_category = main_categories[category_id - 1]
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_sub_category', language,
                    session.get('customer_name'),
                    selected_main_category=selected_category['id']
                )
                
                return self._show_sub_categories(phone_number, selected_category, language)

        elif category_name:
            # Category name matching
            main_categories = self.db.get_main_categories()
            matched_category = self._match_category_by_name(category_name, main_categories, language)
            
            if matched_category:
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_sub_category', language,
                    session.get('customer_name'),
                    selected_main_category=matched_category['id']
                )
                
                return self._show_sub_categories(phone_number, matched_category, language)

        return self._create_response(self._get_fallback_message('waiting_for_category', language))

    def _handle_ai_item_selection(self, phone_number: str, extracted_data: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI item selection"""
        item_id = extracted_data.get('item_id')
        item_name = extracted_data.get('item_name')
        language = user_context.get('language')

        if item_id:
            # Direct item ID selection
            items = self.db.get_sub_category_items(session.get('selected_sub_category'))
            if 1 <= item_id <= len(items):
                selected_item = items[item_id - 1]
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_quantity', language,
                    session.get('customer_name'),
                    selected_main_category=session.get('selected_main_category'),
                    selected_sub_category=session.get('selected_sub_category'),
                    last_selected_item=selected_item['id']
                )
                
                return self._show_quantity_selection(phone_number, selected_item, language)

        elif item_name:
            # Item name matching
            items = self.db.get_sub_category_items(session.get('selected_sub_category'))
            matched_item = self._match_item_by_name(item_name, items, language)
            
            if matched_item:
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_quantity', language,
                    session.get('customer_name'),
                    selected_main_category=session.get('selected_main_category'),
                    selected_sub_category=session.get('selected_sub_category'),
                    last_selected_item=matched_item['id']
                )
                
                return self._show_quantity_selection(phone_number, matched_item, language)

        return self._create_response(self._get_fallback_message('waiting_for_item', language))

    def _handle_ai_quantity_selection(self, phone_number: str, extracted_data: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI quantity selection"""
        quantity = extracted_data.get('quantity')
        language = user_context.get('language')

        if quantity and isinstance(quantity, int) and 1 <= quantity <= 50:
            # Add item to order
            item_id = session.get('last_selected_item')
            if item_id:
                self.db.add_item_to_order(phone_number, item_id, quantity)
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_additional', language,
                    session.get('customer_name'),
                    selected_main_category=session.get('selected_main_category'),
                    selected_sub_category=session.get('selected_sub_category')
                )
                
                # Get item details for confirmation
                items = self.db.get_sub_category_items(session.get('selected_sub_category'))
                selected_item = next((item for item in items if item['id'] == item_id), None)
                
                if selected_item:
                    if language == 'arabic':
                        message = f"ØªÙ… Ø¥Ø¶Ø§ÙØ© {selected_item['item_name_ar']} Ã— {quantity} Ø¥Ù„Ù‰ Ø·Ù„Ø¨Ùƒ\n\nÙ‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£ØµÙ†Ø§ÙØŸ\n\n1. Ù†Ø¹Ù…\n2. Ù„Ø§"
                    else:
                        message = f"Added {selected_item['item_name_en']} Ã— {quantity} to your order\n\nWould you like to add more items?\n\n1. Yes\n2. No"
                    
                    return self._create_response(message)

        return self._create_response(self._get_fallback_message('waiting_for_quantity', language))

    def _handle_ai_yes_no(self, phone_number: str, extracted_data: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI yes/no responses"""
        yes_no = extracted_data.get('yes_no')
        language = user_context.get('language')
        current_step = user_context.get('current_step')

        if yes_no == 'yes':
            if current_step == 'waiting_for_additional':
                # Show main categories again
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_category', language,
                    session.get('customer_name')
                )
                return self._show_main_categories(phone_number, language)
            
            elif current_step == 'waiting_for_confirmation':
                # Confirm order
                return self._confirm_order(phone_number, session, user_context)

        elif yes_no == 'no':
            if current_step == 'waiting_for_additional':
                # Proceed to service selection
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_service', language,
                    session.get('customer_name')
                )
                return self._show_service_selection(phone_number, language)
            
            elif current_step == 'waiting_for_confirmation':
                # Cancel order
                return self._cancel_order(phone_number, session, user_context)

        return self._create_response(self._get_fallback_message(current_step, language))

    def _handle_ai_service_selection(self, phone_number: str, extracted_data: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI service selection"""
        service_type = extracted_data.get('service_type')
        language = user_context.get('language')

        if service_type in ['dine-in', 'delivery']:
            # Update session
            self.db.create_or_update_session(
                phone_number, 'waiting_for_location', language,
                session.get('customer_name'),
                service_type=service_type
            )
            
            if service_type == 'dine-in':
                if language == 'arabic':
                    message = "Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø±Ù‚Ù… Ø§Ù„Ø·Ø§ÙˆÙ„Ø© (1-7):"
                else:
                    message = "Please provide your table number (1-7):"
            else:
                if language == 'arabic':
                    message = "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø´Ø§Ø±ÙƒØ© Ù…ÙˆÙ‚Ø¹Ùƒ ÙˆØ£ÙŠ ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø®Ø§ØµØ©:"
                else:
                    message = "Please share your location and any special instructions:"
            
            return self._create_response(message)

        return self._create_response(self._get_fallback_message('waiting_for_service', language))

    def _handle_ai_location_input(self, phone_number: str, extracted_data: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI location input"""
        location = extracted_data.get('location')
        language = user_context.get('language')

        if location and len(location.strip()) > 0:
            # Update session
            self.db.create_or_update_session(
                phone_number, 'waiting_for_confirmation', language,
                session.get('customer_name'),
                location=location
            )
            
            # Show order summary
            return self._show_order_summary(phone_number, session, user_context, location)

        return self._create_response(self._get_fallback_message('waiting_for_location', language))

    def _handle_ai_confirmation(self, phone_number: str, extracted_data: Dict, session: Dict, user_context: Dict) -> Dict:
        """Handle AI confirmation"""
        # This would handle direct confirmation without yes/no
        return self._confirm_order(phone_number, session, user_context)

    def _handle_ai_show_menu(self, phone_number: str, session: Dict, user_context: Dict) -> Dict:
        """Handle AI show menu request"""
        language = user_context.get('language')
        current_step = user_context.get('current_step')

        if current_step == 'waiting_for_category':
            return self._show_main_categories(phone_number, language)
        elif current_step == 'waiting_for_sub_category':
            main_categories = self.db.get_main_categories()
            selected_category = next((cat for cat in main_categories if cat['id'] == session.get('selected_main_category')), None)
            if selected_category:
                return self._show_sub_categories(phone_number, selected_category, language)
        elif current_step == 'waiting_for_item':
            sub_categories = self.db.get_sub_categories(session.get('selected_main_category'))
            selected_sub_category = next((cat for cat in sub_categories if cat['id'] == session.get('selected_sub_category')), None)
            if selected_sub_category:
                return self._show_sub_category_items(phone_number, selected_sub_category, language)

        return self._create_response(self._get_fallback_message(current_step, language))

    def _handle_ai_help_request(self, phone_number: str, session: Dict, user_context: Dict) -> Dict:
        """Handle AI help request"""
        language = user_context.get('language')
        current_step = user_context.get('current_step')

        if language == 'arabic':
            help_messages = {
                'waiting_for_category': 'ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 3ØŒ Ø£Ùˆ Ù‚Ù„ Ù„ÙŠ Ù…Ø§ ØªØ±ÙŠØ¯ Ø¨Ø§Ù„Ø¶Ø¨Ø· Ù…Ø«Ù„ "Ù…Ø´Ø±ÙˆØ¨ Ø¨Ø§Ø±Ø¯" Ø£Ùˆ "Ø´ÙŠØ¡ Ø­Ù„Ùˆ"',
                'waiting_for_sub_category': 'Ø§Ø®ØªØ± Ø±Ù‚Ù… Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ©ØŒ Ø£Ùˆ Ù‚Ù„ Ù„ÙŠ Ù…Ø§ ØªØ±ÙŠØ¯ Ù…Ø«Ù„ "Ù‚Ù‡ÙˆØ©" Ø£Ùˆ "Ø¹ØµÙŠØ±"',
                'waiting_for_item': 'Ø§Ø®ØªØ± Ø±Ù‚Ù… Ø§Ù„Ù…Ù†ØªØ¬ØŒ Ø£Ùˆ Ù‚Ù„ Ù„ÙŠ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯Ù‡',
                'waiting_for_quantity': 'Ø§ÙƒØªØ¨ Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ 50)',
                'waiting_for_additional': 'Ø§ÙƒØªØ¨ "Ù†Ø¹Ù…" Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ØŒ Ø£Ùˆ "Ù„Ø§" Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©',
                'waiting_for_service': 'Ø§ÙƒØªØ¨ "1" Ù„Ù„ØªÙ†Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…Ù‚Ù‡Ù‰ØŒ Ø£Ùˆ "2" Ù„Ù„ØªÙˆØµÙŠÙ„',
                'waiting_for_location': 'Ø§ÙƒØªØ¨ Ø±Ù‚Ù… Ø§Ù„Ø·Ø§ÙˆÙ„Ø© (1-7) Ù„Ù„ØªÙ†Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…Ù‚Ù‡Ù‰ØŒ Ø£Ùˆ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ù„Ù„ØªÙˆØµÙŠÙ„',
                'waiting_for_confirmation': 'Ø§ÙƒØªØ¨ "Ù†Ø¹Ù…" Ù„ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø·Ù„Ø¨ØŒ Ø£Ùˆ "Ù„Ø§" Ù„Ù„Ø¥Ù„ØºØ§Ø¡'
            }
        else:
            help_messages = {
                'waiting_for_category': 'You can choose a number from 1 to 3, or tell me exactly what you want like "cold drink" or "something sweet"',
                'waiting_for_sub_category': 'Choose the sub-category number, or tell me what you want like "coffee" or "juice"',
                'waiting_for_item': 'Choose the item number, or tell me the name of the item you want',
                'waiting_for_quantity': 'Enter the quantity needed (number from 1 to 50)',
                'waiting_for_additional': 'Type "yes" to add more, or "no" to continue',
                'waiting_for_service': 'Type "1" for dine-in, or "2" for delivery',
                'waiting_for_location': 'Enter table number (1-7) for dine-in, or address for delivery',
                'waiting_for_confirmation': 'Type "yes" to confirm order, or "no" to cancel'
            }

        help_message = help_messages.get(current_step, 'I can help you with your order. What would you like to know?')
        return self._create_response(help_message)

    def _handle_structured_message(self, phone_number: str, text: str, current_step: str, session: Dict, user_context: Dict) -> Dict:
        """Fallback to structured message processing when AI is not available"""
        logger.info(f"ğŸ”„ Using structured processing for: '{text}' at step '{current_step}'")
        
        language = user_context.get('language', 'arabic')
        
        # Handle different steps with structured logic
        if current_step == 'waiting_for_language':
            return self._handle_structured_language_selection(phone_number, text, session)
            
        elif current_step == 'waiting_for_category':
            return self._handle_structured_category_selection(phone_number, text, session, user_context)
            
        elif current_step == 'waiting_for_sub_category':
            return self._handle_structured_sub_category_selection(phone_number, text, session, user_context)
            
        elif current_step == 'waiting_for_item':
            return self._handle_structured_item_selection(phone_number, text, session, user_context)
            
        elif current_step == 'waiting_for_quantity':
            return self._handle_structured_quantity_selection(phone_number, text, session, user_context)
            
        elif current_step == 'waiting_for_additional':
            return self._handle_structured_additional_selection(phone_number, text, session, user_context)
            
        else:
            return self._create_response(self._get_fallback_message(current_step, language))

    def _handle_structured_language_selection(self, phone_number: str, text: str, session: Dict) -> Dict:
        """Handle language selection with structured logic"""
        text_lower = text.lower().strip()
        
        if any(word in text_lower for word in ['Ù…Ø±Ø­Ø¨Ø§', 'Ø§Ù„Ø³Ù„Ø§Ù…', 'Ù‡Ù„Ø§', 'hello', 'hi']):
            # Default to Arabic for Arabic greetings
            if any(word in text_lower for word in ['Ù…Ø±Ø­Ø¨Ø§', 'Ø§Ù„Ø³Ù„Ø§Ù…', 'Ù‡Ù„Ø§']):
                language = 'arabic'
            else:
                language = 'english'
                
            # Update session
            self.db.create_or_update_session(
                phone_number, 'waiting_for_category', language,
                session.get('customer_name')
            )
            
            return self._show_main_categories(phone_number, language)
        
        return self._create_response("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ 'Ù…Ø±Ø­Ø¨Ø§' Ù„Ù„Ø¨Ø¯Ø¡\nPlease send 'hello' to start")

    def _handle_structured_category_selection(self, phone_number: str, text: str, session: Dict, user_context: Dict) -> Dict:
        """Handle category selection with structured logic"""
        language = user_context.get('language', 'arabic')
        
        # Try to extract number
        try:
            category_num = int(text.strip())
            categories = self.db.get_main_categories()
            
            if 1 <= category_num <= len(categories):
                selected_category = categories[category_num - 1]
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_sub_category', language,
                    session.get('customer_name'),
                    selected_main_category=selected_category['id']
                )
                
                return self._show_sub_categories(phone_number, selected_category, language)
            else:
                return self._create_response(f"Ø§Ù„Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† 1 Ø¥Ù„Ù‰ {len(categories)}")
                
        except ValueError:
            # Try to match by name
            categories = self.db.get_main_categories()
            matched_category = self._match_category_by_name(text, categories, language)
            
            if matched_category:
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_sub_category', language,
                    session.get('customer_name'),
                    selected_main_category=matched_category['id']
                )
                
                return self._show_sub_categories(phone_number, matched_category, language)
            else:
                return self._create_response("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø±Ù‚Ù… Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ùˆ ÙƒØªØ§Ø¨Ø© Ø§Ø³Ù… Ø§Ù„ÙØ¦Ø©")

    def _handle_structured_sub_category_selection(self, phone_number: str, text: str, session: Dict, user_context: Dict) -> Dict:
        """Handle sub-category selection with structured logic"""
        language = user_context.get('language', 'arabic')
        main_category_id = session.get('selected_main_category')
        
        if not main_category_id:
            return self._create_response("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯")
        
        # Try to extract number
        try:
            sub_category_num = int(text.strip())
            sub_categories = self.db.get_sub_categories(main_category_id)
            
            if 1 <= sub_category_num <= len(sub_categories):
                selected_sub_category = sub_categories[sub_category_num - 1]
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_item', language,
                    session.get('customer_name'),
                    selected_main_category=main_category_id,
                    selected_sub_category=selected_sub_category['id']
                )
                
                return self._show_sub_category_items(phone_number, selected_sub_category, language)
            else:
                return self._create_response(f"Ø§Ù„Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† 1 Ø¥Ù„Ù‰ {len(sub_categories)}")
                
        except ValueError:
            # Try to match by name
            sub_categories = self.db.get_sub_categories(main_category_id)
            matched_sub_category = self._match_category_by_name(text, sub_categories, language)
            
            if matched_sub_category:
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_item', language,
                    session.get('customer_name'),
                    selected_main_category=main_category_id,
                    selected_sub_category=matched_sub_category['id']
                )
                
                return self._show_sub_category_items(phone_number, matched_sub_category, language)
            else:
                return self._create_response("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø±Ù‚Ù… Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ùˆ ÙƒØªØ§Ø¨Ø© Ø§Ø³Ù… Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ©")

    def _handle_structured_item_selection(self, phone_number: str, text: str, session: Dict, user_context: Dict) -> Dict:
        """Handle item selection with structured logic"""
        language = user_context.get('language', 'arabic')
        sub_category_id = session.get('selected_sub_category')
        
        if not sub_category_id:
            return self._create_response("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯")
        
        # Try to extract number
        try:
            item_num = int(text.strip())
            items = self.db.get_sub_category_items(sub_category_id)
            
            if 1 <= item_num <= len(items):
                selected_item = items[item_num - 1]
                
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_quantity', language,
                    session.get('customer_name'),
                    selected_main_category=session.get('selected_main_category'),
                    selected_sub_category=sub_category_id,
                    selected_item=selected_item['id']
                )
                
                return self._show_quantity_selection(phone_number, selected_item, language)
            else:
                return self._create_response(f"Ø§Ù„Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† 1 Ø¥Ù„Ù‰ {len(items)}")
                
        except ValueError:
            # Try to match by name
            items = self.db.get_sub_category_items(sub_category_id)
            matched_item = self._match_item_by_name(text, items, language)
            
            if matched_item:
                # Update session
                self.db.create_or_update_session(
                    phone_number, 'waiting_for_quantity', language,
                    session.get('customer_name'),
                    selected_main_category=session.get('selected_main_category'),
                    selected_sub_category=sub_category_id,
                    selected_item=matched_item['id']
                )
                
                return self._show_quantity_selection(phone_number, matched_item, language)
            else:
                return self._create_response("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø±Ù‚Ù… Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ùˆ ÙƒØªØ§Ø¨Ø© Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬")

    def _handle_structured_quantity_selection(self, phone_number: str, text: str, session: Dict, user_context: Dict) -> Dict:
        """Handle quantity selection with structured logic"""
        language = user_context.get('language', 'arabic')
        item_id = session.get('selected_item')
        
        if not item_id:
            return self._create_response("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯")
        
        # Extract number from text
        import re
        numbers = re.findall(r'\d+', text)
        
        if numbers:
            quantity = int(numbers[0])
            if quantity > 0:
                # Add item to order
                success = self.db.add_item_to_order(phone_number, item_id, quantity)
                
                if success:
                    # Update session
                    self.db.create_or_update_session(
                        phone_number, 'waiting_for_additional', language,
                        session.get('customer_name')
                    )
                    
                    if language == 'arabic':
                        message = f"ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬ Ø¥Ù„Ù‰ Ø·Ù„Ø¨Ùƒ\n"
                        message += "Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£ØµÙ†Ø§ÙØŸ\n\n"
                        message += "1. Ù†Ø¹Ù…\n"
                        message += "2. Ù„Ø§"
                    else:
                        message = f"Item added to your order\n"
                        message += "Would you like to add more items?\n\n"
                        message += "1. Yes\n"
                        message += "2. No"
                    
                    return self._create_response(message)
                else:
                    return self._create_response("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
        
        return self._create_response("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­")

    def _handle_structured_additional_selection(self, phone_number: str, text: str, session: Dict, user_context: Dict) -> Dict:
        """Handle additional item selection with structured logic"""
        language = user_context.get('language', 'arabic')
        
        # Check for yes/no
        text_lower = text.lower().strip()
        
        if any(word in text_lower for word in ['Ù†Ø¹Ù…', 'yes', '1']):
            # Reset to category selection
            self.db.create_or_update_session(
                phone_number, 'waiting_for_category', language,
                session.get('customer_name')
            )
            
            return self._show_main_categories(phone_number, language)
            
        elif any(word in text_lower for word in ['Ù„Ø§', 'no', '2']):
            # Move to service selection
            self.db.create_or_update_session(
                phone_number, 'waiting_for_service', language,
                session.get('customer_name')
            )
            
            return self._show_service_selection(phone_number, language)
        
        return self._create_response("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø±Ø¯ Ø¨Ù€ '1' Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ø£Ùˆ '2' Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©")

    # Helper methods for UI generation
    def _show_main_categories(self, phone_number: str, language: str) -> Dict:
        """Show main categories"""
        categories = self.db.get_main_categories()
        
        if language == 'arabic':
            message = "Ù…Ù…ØªØ§Ø²! Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:\n\n"
            for i, cat in enumerate(categories, 1):
                message += f"{i}. {cat['name_ar']}\n"
            message += "\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"
        else:
            message = "Great! Choose from the main menu:\n\n"
            for i, cat in enumerate(categories, 1):
                message += f"{i}. {cat['name_en']}\n"
            message += "\nPlease select the required category"
        
        return self._create_response(message)

    def _show_sub_categories(self, phone_number: str, main_category: Dict, language: str) -> Dict:
        """Show sub-categories for selected main category"""
        sub_categories = self.db.get_sub_categories(main_category['id'])
        
        if language == 'arabic':
            message = f"Ù‚Ø§Ø¦Ù…Ø© {main_category['name_ar']}:\n\n"
            for i, sub_cat in enumerate(sub_categories, 1):
                message += f"{i}. {sub_cat['name_ar']}\n"
            message += "\nØ§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"
        else:
            message = f"{main_category['name_en']} Menu:\n\n"
            for i, sub_cat in enumerate(sub_categories, 1):
                message += f"{i}. {sub_cat['name_en']}\n"
            message += "\nPlease select the required sub-category"
        
        return self._create_response(message)

    def _show_sub_category_items(self, phone_number: str, sub_category: Dict, language: str) -> Dict:
        """Show items for selected sub-category"""
        items = self.db.get_sub_category_items(sub_category['id'])
        
        if language == 'arabic':
            message = f"Ù‚Ø§Ø¦Ù…Ø© {sub_category['name_ar']}:\n\n"
            for i, item in enumerate(items, 1):
                message += f"{i}. {item['item_name_ar']}\n"
                message += f"   Ø§Ù„Ø³Ø¹Ø±: {item['price']} Ø¯ÙŠÙ†Ø§Ø±\n\n"
            message += "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨"
        else:
            message = f"{sub_category['name_en']} Menu:\n\n"
            for i, item in enumerate(items, 1):
                message += f"{i}. {item['item_name_en']}\n"
                message += f"   Price: {item['price']} IQD\n\n"
            message += "Please select the required item"
        
        return self._create_response(message)

    def _show_quantity_selection(self, phone_number: str, selected_item: Dict, language: str) -> Dict:
        """Show quantity selection for selected item"""
        if language == 'arabic':
            message = f"ØªÙ… Ø§Ø®ØªÙŠØ§Ø±: {selected_item['item_name_ar']}\n"
            message += f"Ø§Ù„Ø³Ø¹Ø±: {selected_item['price']} Ø¯ÙŠÙ†Ø§Ø±\n"
            message += "ÙƒÙ… Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©ØŸ"
        else:
            message = f"Selected: {selected_item['item_name_en']}\n"
            message += f"Price: {selected_item['price']} IQD\n"
            message += "How many would you like?"
        
        return self._create_response(message)

    def _show_service_selection(self, phone_number: str, language: str) -> Dict:
        """Show service selection"""
        if language == 'arabic':
            message = "Ù‡Ù„ ØªØ±ÙŠØ¯ Ø·Ù„Ø¨Ùƒ Ù„Ù„ØªÙ†Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…Ù‚Ù‡Ù‰ Ø£Ù… Ù„Ù„ØªÙˆØµÙŠÙ„ØŸ\n\n"
            message += "1. ØªÙ†Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…Ù‚Ù‡Ù‰\n"
            message += "2. ØªÙˆØµÙŠÙ„"
        else:
            message = "Do you want your order for dine-in or delivery?\n\n"
            message += "1. Dine-in\n"
            message += "2. Delivery"
        
        return self._create_response(message)

    def _show_order_summary(self, phone_number: str, session: Dict, user_context: Dict, location: str) -> Dict:
        """Show order summary"""
        current_order = self.db.get_current_order(phone_number)
        language = user_context.get('language')
        
        if not current_order or not current_order.get('items'):
            return self._create_response("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ØµÙ†Ø§Ù ÙÙŠ Ø·Ù„Ø¨Ùƒ\nNo items in your order")

        if language == 'arabic':
            message = "Ø¥Ù„ÙŠÙƒ Ù…Ù„Ø®Øµ Ø·Ù„Ø¨Ùƒ:\n\n"
            message += "Ø§Ù„Ø£ØµÙ†Ø§Ù:\n"
            for item in current_order['items']:
                message += f"â€¢ {item['item_name_ar']} Ã— {item['quantity']} - {item['subtotal']} Ø¯ÙŠÙ†Ø§Ø±\n"
            
            message += f"\nØ§Ù„Ø®Ø¯Ù…Ø©: {session.get('service_type', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}\n"
            message += f"Ø§Ù„Ù…ÙƒØ§Ù†: {location}\n"
            message += f"Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {current_order['total']} Ø¯ÙŠÙ†Ø§Ø±\n\n"
            message += "Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ£ÙƒÙŠØ¯ Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨ØŸ\n\n1. Ù†Ø¹Ù…\n2. Ù„Ø§"
        else:
            message = "Here is your order summary:\n\n"
            message += "Items:\n"
            for item in current_order['items']:
                message += f"â€¢ {item['item_name_en']} Ã— {item['quantity']} - {item['subtotal']} IQD\n"
            
            message += f"\nService: {session.get('service_type', 'Not specified')}\n"
            message += f"Location: {location}\n"
            message += f"Total Price: {current_order['total']} IQD\n\n"
            message += "Would you like to confirm this order?\n\n1. Yes\n2. No"
        
        return self._create_response(message)

    def _confirm_order(self, phone_number: str, session: Dict, user_context: Dict) -> Dict:
        """Confirm order"""
        # Complete the order
        order_id = self.db.complete_order(phone_number)
        language = user_context.get('language')
        
        if order_id:
            if language == 'arabic':
                message = f"ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­!\n\n"
                message += f"Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: {order_id}\n"
                message += f"Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…Ù‚Ù‡Ù‰ Ù‡ÙŠÙ!"
            else:
                message = f"Your order has been confirmed successfully!\n\n"
                message += f"Order ID: {order_id}\n"
                message += f"Thank you for choosing Hef Cafe!"
        else:
            if language == 'arabic':
                message = "Ø¹Ø°Ø±Ø§Ù‹ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø·Ù„Ø¨. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©"
            else:
                message = "Sorry, there was an error confirming your order. Please try again"
        
        return self._create_response(message)

    def _cancel_order(self, phone_number: str, session: Dict, user_context: Dict) -> Dict:
        """Cancel order"""
        self.db.cancel_order(phone_number)
        language = user_context.get('language')
        customer_name = session.get('customer_name', 'Customer')
        
        if language == 'arabic':
            message = f"ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨. Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ {customer_name} Ù„Ø²ÙŠØ§Ø±Ø© Ù…Ù‚Ù‡Ù‰ Ù‡ÙŠÙ.\n\n"
            message += "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª Ø¨Ø¥Ø±Ø³Ø§Ù„ 'Ù…Ø±Ø­Ø¨Ø§'"
        else:
            message = f"Order cancelled. Thank you {customer_name} for visiting Hef Cafe.\n\n"
            message += "You can start a new order anytime by sending 'hello'"
        
        return self._create_response(message)

    # Utility methods
    def _match_category_by_name(self, text: str, categories: list, language: str) -> Optional[Dict]:
        """Match category by name"""
        text_lower = text.lower().strip()
        
        for category in categories:
            if language == 'arabic':
                if text_lower in category['name_ar'].lower():
                    return category
            else:
                if text_lower in category['name_en'].lower():
                    return category
        
        return None

    def _match_item_by_name(self, text: str, items: list, language: str) -> Optional[Dict]:
        """Match item by name"""
        text_lower = text.lower().strip()
        
        for item in items:
            if language == 'arabic':
                if text_lower in item['item_name_ar'].lower():
                    return item
            else:
                if text_lower in item['item_name_en'].lower():
                    return item
        
        return None

    def _get_fallback_message(self, current_step: str, language: str) -> str:
        """Get fallback message for current step"""
        if language == 'arabic':
            messages = {
                'waiting_for_language': 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù„ØºØªÙƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©:\n1. Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\n2. English',
                'waiting_for_category': 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:\n1. Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª Ø§Ù„Ø¨Ø§Ø±Ø¯Ø©\n2. Ø§Ù„Ù…Ø´Ø±ÙˆØ¨Ø§Øª Ø§Ù„Ø­Ø§Ø±Ø©\n3. Ø§Ù„Ø­Ù„ÙˆÙŠØ§Øª ÙˆØ§Ù„Ù…Ø¹Ø¬Ù†Ø§Øª',
                'waiting_for_sub_category': 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø© Ø§Ù„ÙØ±Ø¹ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©',
                'waiting_for_item': 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨',
                'waiting_for_quantity': 'ÙƒÙ… Ø§Ù„ÙƒÙ…ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©ØŸ',
                'waiting_for_additional': 'Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£ØµÙ†Ø§ÙØŸ\n1. Ù†Ø¹Ù…\n2. Ù„Ø§',
                'waiting_for_service': 'Ù‡Ù„ ØªØ±ÙŠØ¯ Ø·Ù„Ø¨Ùƒ Ù„Ù„ØªÙ†Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…Ù‚Ù‡Ù‰ Ø£Ù… Ù„Ù„ØªÙˆØµÙŠÙ„ØŸ\n1. ØªÙ†Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„Ù…Ù‚Ù‡Ù‰\n2. ØªÙˆØµÙŠÙ„',
                'waiting_for_location': 'Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø±Ù‚Ù… Ø§Ù„Ø·Ø§ÙˆÙ„Ø© (1-7) Ø£Ùˆ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†',
                'waiting_for_confirmation': 'Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ£ÙƒÙŠØ¯ Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨ØŸ\n1. Ù†Ø¹Ù…\n2. Ù„Ø§'
            }
        else:
            messages = {
                'waiting_for_language': 'Please select your preferred language:\n1. Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Arabic)\n2. English',
                'waiting_for_category': 'Please select from the menu:\n1. Cold Drinks\n2. Hot Drinks\n3. Pastries & Sweets',
                'waiting_for_sub_category': 'Please select the required sub-category',
                'waiting_for_item': 'Please select the required item',
                'waiting_for_quantity': 'How many would you like?',
                'waiting_for_additional': 'Would you like to add more items?\n1. Yes\n2. No',
                'waiting_for_service': 'Do you want your order for dine-in or delivery?\n1. Dine-in\n2. Delivery',
                'waiting_for_location': 'Please provide your table number (1-7) or address',
                'waiting_for_confirmation': 'Would you like to confirm this order?\n1. Yes\n2. No'
            }
        
        return messages.get(current_step, 'Please provide a valid response.')

    def _extract_customer_name(self, message_data: Dict) -> str:
        """Extract customer name from message data"""
        profile = message_data.get('profile', {})
        return profile.get('name', 'Customer')

    def _create_response(self, content: str) -> Dict[str, Any]:
        """Create response structure"""
        return {
            'response_type': 'text',
            'content': content,
            'timestamp': datetime.now().isoformat()
        } 